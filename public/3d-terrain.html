<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>B·∫£n ƒë·ªì 3D Vi·ªát Nam - ƒê·ªãa h√¨nh 34 T·ªânh Th√†nh</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            overflow: hidden;
            background: #1a3a4a;
        }
        
        #app { width: 100vw; height: 100vh; position: relative; }
        
        /* Loading */
        #loading {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #3d7a8c 0%, #1a4a5a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s;
        }
        
        #loading.hidden { opacity: 0; pointer-events: none; }
        
        .loader {
            width: 50px; height: 50px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        #loading h1 {
            margin-top: 20px;
            font-size: 1.5rem;
            font-weight: 300;
            color: #fff;
            letter-spacing: 5px;
        }
        
        /* Title */
        #title {
            position: fixed;
            top: 25px;
            left: 25px;
            z-index: 100;
            color: #fff;
        }
        
        #title h1 {
            font-size: 1.6rem;
            font-weight: 700;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #title .subtitle {
            font-size: 0.8rem;
            font-weight: 300;
            opacity: 0.85;
            margin-top: 5px;
        }
        
        /* Legend */
        #legend {
            position: fixed;
            bottom: 25px;
            left: 25px;
            background: rgba(255,255,255,0.12);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 12px;
            z-index: 100;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
        }
        
        #legend h4 {
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            opacity: 0.8;
            text-transform: uppercase;
        }
        
        .legend-bar {
            display: flex;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            width: 180px;
        }
        
        .legend-bar div { flex: 1; }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            margin-top: 6px;
            opacity: 0.7;
        }
        
        /* Province Panel */
        #panel {
            position: fixed;
            right: 20px;
            top: 20px;
            bottom: 20px;
            width: 280px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff;
        }
        
        #panel-header {
            padding: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        #panel-header h3 {
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        #search {
            width: 100%;
            padding: 10px 14px;
            margin-top: 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            color: #fff;
            font-family: inherit;
            font-size: 0.85rem;
            outline: none;
        }
        
        #search::placeholder { color: rgba(255,255,255,0.5); }
        #search:focus { border-color: rgba(255,255,255,0.4); }
        
        #province-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
        }
        
        #province-list::-webkit-scrollbar { width: 4px; }
        #province-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        #province-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        .region-title {
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.5);
            margin: 15px 0 8px;
            text-transform: uppercase;
        }
        
        .province-item {
            padding: 10px 12px;
            margin: 3px 0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .province-item:hover { background: rgba(255,255,255,0.1); }
        .province-item.selected { background: rgba(255,200,100,0.25); }
        
        .province-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: #7cb342;
            flex-shrink: 0;
        }
        
        .province-item.capital .province-dot { background: #ffd54f; }
        .province-item.major .province-dot { background: #64b5f6; }
        
        /* Detail Card */
        #detail {
            position: fixed;
            left: 25px;
            top: 120px;
            width: 300px;
            background: rgba(255,255,255,0.12);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 20px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff;
        }
        
        #detail.active { display: block; animation: fadeIn 0.3s ease; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #detail h2 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        #detail .type {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .type.capital { background: rgba(255,213,79,0.3); color: #ffd54f; }
        .type.major { background: rgba(100,181,246,0.3); color: #64b5f6; }
        .type.province { background: rgba(124,179,66,0.3); color: #aed581; }
        
        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .detail-item {
            background: rgba(255,255,255,0.08);
            padding: 10px;
            border-radius: 8px;
        }
        
        .detail-item label {
            display: block;
            font-size: 0.65rem;
            opacity: 0.6;
            margin-bottom: 3px;
            text-transform: uppercase;
        }
        
        .detail-item .value {
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .merged-info {
            background: rgba(255,193,7,0.15);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 0.8rem;
            border-left: 3px solid #ffc107;
        }
        
        .features {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .feature-tag {
            padding: 4px 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            font-size: 0.7rem;
        }
        
        #close-detail {
            position: absolute;
            top: 12px; right: 12px;
            width: 26px; height: 26px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: #fff;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #close-detail:hover { background: rgba(255,255,255,0.2); }
        
        /* Controls */
        #controls {
            position: fixed;
            bottom: 25px;
            right: 320px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
            z-index: 100;
        }
        
        /* Camera feed */
        #camera-feed {
            position: fixed;
            top: 20px;
            right: 320px;
            width: 130px;
            height: 98px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 100;
            background: #000;
        }
        
        #webcam {
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #hand-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1);
        }
        
        /* Responsive */
        @media (max-width: 900px) {
            #panel { width: 240px; }
            #camera-feed { display: none; }
            #controls { right: 260px; }
        }
        
        @media (max-width: 700px) {
            #panel { 
                width: calc(100% - 40px);
                height: auto;
                max-height: 35vh;
                top: auto;
                bottom: 20px;
            }
            #detail {
                width: calc(100% - 40px);
                left: 20px;
                top: 100px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="loading">
            <div class="loader"></div>
            <h1>VIETNAM</h1>
        </div>
        
        <div id="title">
            <h1>üáªüá≥ VI·ªÜT NAM</h1>
            <div class="subtitle">B·∫£n ƒë·ªì ƒë·ªãa h√¨nh 3D ‚Ä¢ 34 T·ªânh Th√†nh 2025</div>
        </div>
        
        <div id="legend">
            <h4>ƒê·ªô cao ƒë·ªãa h√¨nh</h4>
            <div class="legend-bar">
                <div style="background: #2d5a3d"></div>
                <div style="background: #4a8c3a"></div>
                <div style="background: #8bc34a"></div>
                <div style="background: #c5d16a"></div>
                <div style="background: #d4a855"></div>
                <div style="background: #b8864a"></div>
                <div style="background: #8b6340"></div>
            </div>
            <div class="legend-labels">
                <span>0m</span>
                <span>1000m</span>
                <span>3000m+</span>
            </div>
        </div>
        
        <div id="panel">
            <div id="panel-header">
                <h3>üìã 34 T·ªàNH TH√ÄNH</h3>
                <input type="text" id="search" placeholder="üîç T√¨m ki·∫øm...">
            </div>
            <div id="province-list"></div>
        </div>
        
        <div id="detail">
            <button id="close-detail">√ó</button>
            <h2 id="detail-name">H√† N·ªôi</h2>
            <div class="type capital" id="detail-type">TH·ª¶ ƒê√î</div>
            <div class="detail-grid">
                <div class="detail-item">
                    <label>Di·ªán t√≠ch</label>
                    <div class="value" id="detail-area">--</div>
                </div>
                <div class="detail-item">
                    <label>D√¢n s·ªë</label>
                    <div class="value" id="detail-pop">--</div>
                </div>
                <div class="detail-item">
                    <label>V√πng</label>
                    <div class="value" id="detail-region">--</div>
                </div>
                <div class="detail-item">
                    <label>M·∫≠t ƒë·ªô</label>
                    <div class="value" id="detail-density">--</div>
                </div>
            </div>
            <div class="merged-info" id="detail-merged" style="display:none">
                <strong>S√°p nh·∫≠p t·ª´:</strong> <span id="merged-text"></span>
            </div>
            <div class="features" id="detail-features"></div>
        </div>
        
        <div id="controls">üñ±Ô∏è K√©o: Xoay ‚Ä¢ Scroll: Zoom ‚Ä¢ Click: Ch·ªçn t·ªânh</div>
        
        <div id="camera-feed">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="hand-canvas"></canvas>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
    
    <script>
        // ============================================
        // VIETNAM 3D TOPOGRAPHIC MAP
        // Only Vietnam + Islands, Province boundaries
        // ============================================
        
        // 34 Provinces data with boundaries
        const PROVINCES = [
            // TH·ª¶ ƒê√î
            { id: 'hanoi', name: 'H√† N·ªôi', type: 'capital', region: 'B·∫Øc', lat: 21.03, lon: 105.85, area: 3359.84, pop: 8.81, features: ['Th·ªß ƒë√¥', 'H·ªì Ho√†n Ki·∫øm', 'VƒÉn Mi·∫øu'], merged: null, elevation: 'low',
              bounds: [[21.55,105.28],[21.55,106.02],[21.25,106.05],[20.85,105.85],[21.00,105.45],[21.45,105.35]] },
            
            // TP TR·ª∞C THU·ªòC TW
            { id: 'haiphong', name: 'H·∫£i Ph√≤ng', type: 'major', region: 'B·∫Øc', lat: 20.86, lon: 106.68, area: 3194.70, pop: 4.66, features: ['C·∫£ng bi·ªÉn', 'C√°t B√†', 'ƒê·ªì S∆°n'], merged: 'H·∫£i D∆∞∆°ng + H·∫£i Ph√≤ng', elevation: 'low',
              bounds: [[21.15,106.10],[21.15,106.90],[20.65,106.85],[20.55,106.35],[20.90,106.10]] },
            { id: 'hue', name: 'Hu·∫ø', type: 'major', region: 'Trung', lat: 16.46, lon: 107.60, area: 4947.11, pop: 1.43, features: ['C·ªë ƒë√¥ UNESCO', 'S√¥ng H∆∞∆°ng', 'ƒê·∫°i N·ªôi'], merged: null, elevation: 'medium',
              bounds: [[16.85,107.00],[16.85,108.20],[16.05,107.95],[16.15,107.25],[16.55,107.00]] },
            { id: 'danang', name: 'ƒê√† N·∫µng', type: 'major', region: 'Trung', lat: 15.90, lon: 108.10, area: 11859.60, pop: 3.07, features: ['C·∫ßu R·ªìng', 'B√† N√†', 'H·ªôi An'], merged: 'Qu·∫£ng Nam + ƒê√† N·∫µng', elevation: 'medium',
              bounds: [[16.30,107.50],[16.20,108.45],[15.35,108.55],[15.05,108.00],[15.45,107.40],[15.95,107.40]] },
            { id: 'hcm', name: 'TP. H·ªì Ch√≠ Minh', type: 'major', region: 'Nam', lat: 10.82, lon: 106.75, area: 6772.60, pop: 14.00, features: ['Kinh t·∫ø', 'Landmark 81', 'B·∫øn Th√†nh'], merged: 'B√¨nh D∆∞∆°ng + TPHCM + BR-VT', elevation: 'low',
              bounds: [[11.20,106.35],[11.20,107.15],[10.45,107.15],[10.35,106.45],[10.80,106.25]] },
            { id: 'cantho', name: 'C·∫ßn Th∆°', type: 'major', region: 'Nam', lat: 10.03, lon: 105.78, area: 6360.80, pop: 4.20, features: ['Ch·ª£ n·ªïi', 'ƒêBSCL', 'Ninh Ki·ªÅu'], merged: 'S√≥c TrƒÉng + H·∫≠u Giang + CT', elevation: 'low',
              bounds: [[10.45,105.35],[10.50,106.15],[9.55,105.85],[9.50,105.30],[10.15,105.25]] },
            
            // MI·ªÄN B·∫ÆC
            { id: 'bacninh', name: 'B·∫Øc Ninh', type: 'province', region: 'B·∫Øc', lat: 21.35, lon: 106.25, area: 4718.60, pop: 3.62, features: ['Quan h·ªç', 'Samsung'], merged: 'B·∫Øc Giang + B·∫Øc Ninh', elevation: 'low',
              bounds: [[21.65,105.90],[21.70,106.75],[21.00,106.65],[21.05,105.90]] },
            { id: 'hungyen', name: 'H∆∞ng Y√™n', type: 'province', region: 'B·∫Øc', lat: 20.65, lon: 106.15, area: 2514.80, pop: 3.57, features: ['Nh√£n l·ªìng', 'Ph·ªë Hi·∫øn'], merged: 'Th√°i B√¨nh + H∆∞ng Y√™n', elevation: 'low',
              bounds: [[20.90,105.90],[20.95,106.55],[20.25,106.55],[20.35,105.80]] },
            { id: 'ninhbinh', name: 'Ninh B√¨nh', type: 'province', region: 'B·∫Øc', lat: 20.15, lon: 105.92, area: 3942.60, pop: 4.41, features: ['Tr√†ng An UNESCO', 'Tam C·ªëc'], merged: 'H√† Nam + Ninh B√¨nh + Nam ƒê·ªãnh', elevation: 'medium',
              bounds: [[20.55,105.55],[20.60,106.35],[19.85,106.15],[19.85,105.55]] },
            { id: 'quangninh', name: 'Qu·∫£ng Ninh', type: 'province', region: 'B·∫Øc', lat: 21.15, lon: 107.35, area: 6207.93, pop: 1.50, features: ['V·ªãnh H·∫° Long UNESCO', 'M√≥ng C√°i'], merged: null, elevation: 'medium',
              bounds: [[21.65,106.75],[21.55,108.10],[20.85,107.50],[21.05,106.75]] },
            { id: 'laocai', name: 'L√†o Cai', type: 'province', region: 'B·∫Øc', lat: 22.35, lon: 104.15, area: 13257.00, pop: 1.78, features: ['Sa Pa', 'Fansipan 3143m'], merged: 'L√†o Cai + Y√™n B√°i', elevation: 'high',
              bounds: [[22.85,103.45],[22.90,104.90],[21.70,104.70],[21.80,103.55]] },
            { id: 'tuyenquang', name: 'Tuy√™n Quang', type: 'province', region: 'B·∫Øc', lat: 22.55, lon: 105.20, area: 13795.60, pop: 1.87, features: ['ATK T√¢n Tr√†o', 'Cao nguy√™n ƒë√°'], merged: 'H√† Giang + Tuy√™n Quang', elevation: 'high',
              bounds: [[23.35,104.45],[23.40,105.85],[21.90,105.45],[21.90,104.45]] },
            { id: 'thainguyen', name: 'Th√°i Nguy√™n', type: 'province', region: 'B·∫Øc', lat: 21.85, lon: 105.85, area: 8375.30, pop: 1.80, features: ['Ch√® Th√°i Nguy√™n', 'H·ªì N√∫i C·ªëc'], merged: 'B·∫Øc K·∫°n + Th√°i Nguy√™n', elevation: 'medium',
              bounds: [[22.35,105.45],[22.35,106.35],[21.45,106.10],[21.55,105.45]] },
            { id: 'phutho', name: 'Ph√∫ Th·ªç', type: 'province', region: 'B·∫Øc', lat: 21.25, lon: 105.10, area: 9361.40, pop: 4.02, features: ['ƒê·ªÅn H√πng', 'H√°t Xoan UNESCO'], merged: 'H√≤a B√¨nh + Vƒ©nh Ph√∫c + Ph√∫ Th·ªç', elevation: 'medium',
              bounds: [[21.90,104.55],[21.95,105.55],[20.80,105.25],[20.80,104.55]] },
            { id: 'sonla', name: 'S∆°n La', type: 'province', region: 'B·∫Øc', lat: 21.35, lon: 103.90, area: 14109.83, pop: 1.40, features: ['M·ªôc Ch√¢u', 'Th·ªßy ƒëi·ªán'], merged: null, elevation: 'high',
              bounds: [[22.00,103.10],[22.10,104.55],[20.65,104.20],[20.65,103.10]] },
            { id: 'dienbien', name: 'ƒêi·ªán Bi√™n', type: 'province', region: 'B·∫Øc', lat: 21.40, lon: 103.00, area: 9539.93, pop: 0.67, features: ['ƒêi·ªán Bi√™n Ph·ªß', 'L·ªãch s·ª≠'], merged: null, elevation: 'high',
              bounds: [[22.35,102.15],[22.40,103.25],[21.00,103.20],[21.05,102.15]] },
            { id: 'laichau', name: 'Lai Ch√¢u', type: 'province', region: 'B·∫Øc', lat: 22.40, lon: 103.25, area: 9068.73, pop: 0.51, features: ['√î Quy H·ªì', 'Bi√™n gi·ªõi'], merged: null, elevation: 'high',
              bounds: [[22.90,102.80],[22.95,103.70],[21.90,103.50],[21.90,102.80]] },
            { id: 'caobang', name: 'Cao B·∫±ng', type: 'province', region: 'B·∫Øc', lat: 22.70, lon: 106.20, area: 6700.39, pop: 0.57, features: ['Th√°c B·∫£n Gi·ªëc', 'P√°c B√≥'], merged: null, elevation: 'high',
              bounds: [[23.15,105.65],[23.20,106.85],[22.10,106.55],[22.30,105.65]] },
            { id: 'langson', name: 'L·∫°ng S∆°n', type: 'province', region: 'B·∫Øc', lat: 21.85, lon: 106.76, area: 8310.18, pop: 0.88, features: ['C·ª≠a kh·∫©u', 'Chi LƒÉng'], merged: null, elevation: 'medium',
              bounds: [[22.45,106.25],[22.50,107.15],[21.40,106.95],[21.60,106.25]] },
            
            // MI·ªÄN TRUNG
            { id: 'thanhhoa', name: 'Thanh H√≥a', type: 'province', region: 'Trung', lat: 19.80, lon: 105.55, area: 11114.71, pop: 4.32, features: ['Th√†nh nh√† H·ªì', 'S·∫ßm S∆°n'], merged: null, elevation: 'medium',
              bounds: [[20.40,104.45],[20.45,106.10],[19.30,105.95],[19.35,104.45]] },
            { id: 'nghean', name: 'Ngh·ªá An', type: 'province', region: 'Trung', lat: 19.20, lon: 105.20, area: 16486.49, pop: 3.83, features: ['Qu√™ B√°c', 'C·ª≠a L√≤'], merged: null, elevation: 'medium',
              bounds: [[19.85,103.85],[19.90,105.95],[18.60,105.65],[18.65,103.85]] },
            { id: 'hatinh', name: 'H√† Tƒ©nh', type: 'province', region: 'Trung', lat: 18.35, lon: 105.70, area: 5994.45, pop: 1.62, features: ['Nguy·ªÖn Du', 'Formosa'], merged: null, elevation: 'medium',
              bounds: [[18.85,105.15],[18.90,106.40],[17.85,106.05],[18.05,105.15]] },
            { id: 'quangtri', name: 'Qu·∫£ng Tr·ªã', type: 'province', region: 'Trung', lat: 17.10, lon: 106.80, area: 12700.00, pop: 1.87, features: ['DMZ', 'Phong Nha'], merged: 'Qu·∫£ng B√¨nh + Qu·∫£ng Tr·ªã', elevation: 'medium',
              bounds: [[17.90,105.65],[17.95,107.40],[16.80,107.15],[17.00,105.65]] },
            { id: 'quangngai', name: 'Qu·∫£ng Ng√£i', type: 'province', region: 'Trung', lat: 15.00, lon: 108.60, area: 14832.60, pop: 2.16, features: ['L√Ω S∆°n', 'Dung Qu·∫•t'], merged: 'Qu·∫£ng Ng√£i + Kon Tum', elevation: 'high',
              bounds: [[15.55,107.65],[15.60,109.20],[14.15,108.95],[14.20,107.65]] },
            { id: 'gialai', name: 'Gia Lai', type: 'province', region: 'Trung', lat: 13.80, lon: 108.30, area: 21576.50, pop: 3.58, features: ['Pleiku', 'Bi·ªÉn H·ªì'], merged: 'Gia Lai + B√¨nh ƒê·ªãnh', elevation: 'high',
              bounds: [[14.50,107.40],[14.55,109.35],[13.00,109.05],[13.05,107.40]] },
            { id: 'daklak', name: 'ƒê·∫Øk L·∫Øk', type: 'province', region: 'Trung', lat: 12.70, lon: 108.30, area: 18096.40, pop: 3.35, features: ['Bu√¥n Ma Thu·ªôt', 'C√† ph√™', 'Voi'], merged: 'Ph√∫ Y√™n + ƒê·∫Øk L·∫Øk', elevation: 'high',
              bounds: [[13.35,107.50],[13.40,109.55],[11.85,109.20],[11.95,107.50]] },
            { id: 'lamdong', name: 'L√¢m ƒê·ªìng', type: 'province', region: 'Trung', lat: 11.70, lon: 108.20, area: 24233.10, pop: 3.87, features: ['ƒê√† L·∫°t', 'Lang Biang'], merged: 'ƒê·∫Øk N√¥ng + L√¢m ƒê·ªìng + B√¨nh Thu·∫≠n', elevation: 'high',
              bounds: [[12.30,107.25],[12.35,109.30],[10.80,108.95],[10.95,107.25]] },
            { id: 'khanhhoa', name: 'Kh√°nh H√≤a', type: 'province', region: 'Trung', lat: 12.25, lon: 109.20, area: 8555.90, pop: 2.24, features: ['Nha Trang', 'Vinpearl'], merged: 'Kh√°nh H√≤a + Ninh Thu·∫≠n', elevation: 'medium',
              bounds: [[12.95,108.65],[13.00,109.65],[11.40,109.40],[11.60,108.65]] },
            
            // MI·ªÄN NAM
            { id: 'dongnai', name: 'ƒê·ªìng Nai', type: 'province', region: 'Nam', lat: 11.20, lon: 107.15, area: 12737.20, pop: 4.49, features: ['Bi√™n H√≤a', 'KCN', 'C√°t Ti√™n'], merged: 'B√¨nh Ph∆∞·ªõc + ƒê·ªìng Nai', elevation: 'low',
              bounds: [[12.10,106.65],[12.15,107.80],[10.70,107.40],[10.85,106.65]] },
            { id: 'tayninh', name: 'T√¢y Ninh', type: 'province', region: 'Nam', lat: 11.35, lon: 106.05, area: 8536.50, pop: 3.25, features: ['N√∫i B√† ƒêen', 'Cao ƒê√†i'], merged: 'Long An + T√¢y Ninh', elevation: 'low',
              bounds: [[11.85,105.50],[11.90,106.65],[10.45,106.45],[10.60,105.50]] },
            { id: 'dongthap', name: 'ƒê·ªìng Th√°p', type: 'province', region: 'Nam', lat: 10.50, lon: 105.70, area: 5938.70, pop: 4.37, features: ['Sen h·ªìng', 'Tr√†m chim'], merged: 'Ti·ªÅn Giang + ƒê·ªìng Th√°p', elevation: 'low',
              bounds: [[10.95,105.35],[11.00,106.40],[9.65,106.10],[9.85,105.35]] },
            { id: 'angiang', name: 'An Giang', type: 'province', region: 'Nam', lat: 10.50, lon: 105.00, area: 9888.90, pop: 4.95, features: ['Ch√¢u ƒê·ªëc', 'Ph√∫ Qu·ªëc'], merged: 'Ki√™n Giang + An Giang', elevation: 'low',
              bounds: [[10.95,104.20],[11.00,105.50],[9.30,105.35],[9.45,104.20]] },
            { id: 'vinhlong', name: 'Vƒ©nh Long', type: 'province', region: 'Nam', lat: 10.10, lon: 106.10, area: 6296.20, pop: 4.26, features: ['C√π lao', 'Mi·ªát v∆∞·ªùn'], merged: 'B·∫øn Tre + Vƒ©nh Long + Tr√† Vinh', elevation: 'low',
              bounds: [[10.60,105.75],[10.65,106.75],[9.30,106.45],[9.50,105.75]] },
            { id: 'camau', name: 'C√† Mau', type: 'province', region: 'Nam', lat: 9.10, lon: 105.10, area: 7942.40, pop: 2.61, features: ['M≈©i C√† Mau', 'C·ª±c Nam'], merged: 'B·∫°c Li√™u + C√† Mau', elevation: 'low',
              bounds: [[9.75,104.55],[9.80,105.85],[8.55,105.45],[8.75,104.55]] }
        ];
        
        // Vietnam main boundary
        const VIETNAM_BOUNDARY = [
            [108.05, 21.55], [107.04, 21.81], [106.57, 22.22], [106.73, 22.79],
            [105.81, 22.98], [105.33, 23.35], [104.48, 22.82], [103.50, 22.70],
            [102.71, 22.71], [102.17, 22.46], [102.75, 21.68], [103.20, 20.77],
            [104.44, 20.76], [104.82, 19.89], [104.18, 19.62], [103.90, 19.27],
            [105.09, 18.67], [105.93, 17.49], [106.56, 16.60], [107.31, 15.91],
            [107.56, 15.20], [107.38, 14.20], [107.61, 13.54], [107.49, 12.34],
            [105.81, 11.57], [106.25, 10.96], [105.20, 10.89], [104.33, 10.49],
            [105.08, 9.92], [104.80, 9.24], [105.16, 8.60], [106.41, 9.53],
            [107.22, 10.36], [108.37, 11.01], [109.20, 11.67], [109.34, 13.43],
            [108.88, 15.28], [108.27, 16.08], [107.36, 16.70], [106.43, 18.00],
            [105.66, 19.06], [105.88, 19.75], [106.72, 20.70], [108.05, 21.55]
        ];
        
        // Islands
        const ISLANDS = [
            { name: 'C√°t B√†', lat: 20.73, lon: 106.98, size: 0.15 },
            { name: 'C√¥ T√¥', lat: 21.05, lon: 107.77, size: 0.08 },
            { name: 'B·∫°ch Long Vƒ©', lat: 20.13, lon: 107.72, size: 0.05 },
            { name: 'C·ªìn C·ªè', lat: 17.16, lon: 107.34, size: 0.04 },
            { name: 'L√Ω S∆°n', lat: 15.38, lon: 109.12, size: 0.06 },
            { name: 'C√π Lao Ch√†m', lat: 15.95, lon: 108.52, size: 0.05 },
            { name: 'Ph√∫ Qu√Ω', lat: 10.52, lon: 108.95, size: 0.06 },
            { name: 'C√¥n ƒê·∫£o', lat: 8.68, lon: 106.60, size: 0.10 },
            { name: 'Ph√∫ Qu·ªëc', lat: 10.22, lon: 103.96, size: 0.25 },
            { name: 'Th·ªï Chu', lat: 9.32, lon: 103.48, size: 0.06 },
            { name: 'Nam Du', lat: 9.68, lon: 104.38, size: 0.05 }
        ];
        
        // Archipelagos with sovereignty
        const ARCHIPELAGOS = [
            { name: 'Qu·∫ßn ƒë·∫£o Ho√†ng Sa', lat: 16.50, lon: 112.00 },
            { name: 'Qu·∫ßn ƒë·∫£o Tr∆∞·ªùng Sa', lat: 9.50, lon: 113.00 }
        ];
        
        let scene, camera, renderer;
        let mapGroup, vietnamMesh, provinceMeshes = {};
        let targetRotX = 0.65, currentRotX = 0.65;
        let targetRotY = 0, currentRotY = 0;
        let targetZoom = 1, currentZoom = 1;
        let isDragging = false, prevMouse = { x: 0, y: 0 };
        let raycaster, mouse;
        let selectedProvince = null;
        let hands, handCamera, lastPinchDist = 0;
        
        const CENTER_LAT = 16.0, CENTER_LON = 106.5, SCALE = 0.38;
        
        init();
        
        async function init() {
            initThree();
            createOcean();
            createVietnamTerrain();
            createProvinceBoundaries();
            createIslands();
            createArchipelagos();
            createProvinceList();
            setupControls();
            await initHandTracking();
            
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 600);
            
            animate();
        }
        
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x3d7a8c);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 7);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('app').appendChild(renderer.domElement);
            
            mapGroup = new THREE.Group();
            scene.add(mapGroup);
            
            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.55);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(5, 12, 5);
            scene.add(sun);
            
            const fill = new THREE.DirectionalLight(0x87ceeb, 0.25);
            fill.position.set(-5, 5, -5);
            scene.add(fill);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function latLonToXZ(lat, lon) {
            return {
                x: (lon - CENTER_LON) * SCALE,
                z: -(lat - CENTER_LAT) * SCALE
            };
        }
        
        function createOcean() {
            const oceanGeo = new THREE.PlaneGeometry(25, 25, 80, 80);
            const positions = oceanGeo.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] = Math.sin(positions[i] * 1.5) * 0.015 + Math.cos(positions[i + 1] * 1.5) * 0.015;
            }
            oceanGeo.computeVertexNormals();
            
            const oceanMat = new THREE.MeshPhongMaterial({
                color: 0x3d8aa5,
                specular: 0x5abcd8,
                shininess: 40,
                transparent: true,
                opacity: 0.95
            });
            
            const ocean = new THREE.Mesh(oceanGeo, oceanMat);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.y = -0.02;
            mapGroup.add(ocean);
        }
        
        function createVietnamTerrain() {
            // Create terrain shape from boundary
            const shape = new THREE.Shape();
            
            VIETNAM_BOUNDARY.forEach((coord, i) => {
                const pos = latLonToXZ(coord[1], coord[0]);
                if (i === 0) shape.moveTo(pos.x, pos.z);
                else shape.lineTo(pos.x, pos.z);
            });
            shape.closePath();
            
            // Extrude for 3D effect
            const extrudeSettings = {
                steps: 1,
                depth: 0.08,
                bevelEnabled: true,
                bevelThickness: 0.02,
                bevelSize: 0.01,
                bevelSegments: 2
            };
            
            const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Rotate to lay flat
            geo.rotateX(-Math.PI / 2);
            
            // Apply vertex colors for terrain
            const positions = geo.attributes.position.array;
            const colors = [];
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                
                // Convert back to lat/lon
                const lon = x / SCALE + CENTER_LON;
                const lat = -z / SCALE + CENTER_LAT;
                
                // Get terrain height/color
                let height = getTerrainHeight(lat, lon);
                let color = getTerrainColor(height);
                
                // Add variation
                color.r += (Math.random() - 0.5) * 0.03;
                color.g += (Math.random() - 0.5) * 0.03;
                color.b += (Math.random() - 0.5) * 0.02;
                
                colors.push(color.r, color.g, color.b);
            }
            
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const mat = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: false,
                shininess: 5
            });
            
            vietnamMesh = new THREE.Mesh(geo, mat);
            vietnamMesh.position.y = 0;
            mapGroup.add(vietnamMesh);
            
            // White border
            createWhiteBorder();
        }
        
        function getTerrainHeight(lat, lon) {
            let h = 0;
            
            // T√¢y B·∫Øc
            if (lon >= 102.5 && lon <= 105 && lat >= 20 && lat <= 23) {
                const d = Math.min(Math.abs(lon - 103.5) / 1.5, Math.abs(lat - 21.5) / 1.5);
                h = Math.max(h, (1 - d) * 0.9);
            }
            // ƒê√¥ng B·∫Øc
            if (lon >= 105 && lon <= 108 && lat >= 21 && lat <= 23.5) {
                const d = Math.sqrt(Math.pow((lon - 106) / 1.5, 2) + Math.pow((lat - 22) / 1.5, 2));
                h = Math.max(h, (1 - Math.min(d, 1)) * 0.6);
            }
            // Tr∆∞·ªùng S∆°n
            if (lon >= 104.5 && lon <= 108.5 && lat >= 14 && lat <= 20) {
                const ridge = Math.abs(lon - (105 + (20 - lat) * 0.2));
                h = Math.max(h, Math.exp(-ridge * 2) * 0.65);
            }
            // T√¢y Nguy√™n
            if (lon >= 107 && lon <= 109 && lat >= 11 && lat <= 15) {
                const d = Math.sqrt(Math.pow((lon - 108) / 1.2, 2) + Math.pow((lat - 13) / 2, 2));
                h = Math.max(h, (1 - Math.min(d, 1)) * 0.75);
            }
            
            return h;
        }
        
        function getTerrainColor(h) {
            if (h < 0.15) return new THREE.Color(0x3d7a4a); // Lowland green
            if (h < 0.30) return new THREE.Color(0x5a9c52); // Light green
            if (h < 0.45) return new THREE.Color(0x8bc34a); // Yellow green
            if (h < 0.55) return new THREE.Color(0xc5c864); // Yellow
            if (h < 0.70) return new THREE.Color(0xc9a055); // Tan
            if (h < 0.82) return new THREE.Color(0xa67845); // Brown
            return new THREE.Color(0x8b5a38); // Dark brown
        }
        
        function createWhiteBorder() {
            const points = VIETNAM_BOUNDARY.map(coord => {
                const pos = latLonToXZ(coord[1], coord[0]);
                return new THREE.Vector3(pos.x, 0.12, pos.z);
            });
            points.push(points[0].clone());
            
            const borderGeo = new THREE.BufferGeometry().setFromPoints(points);
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const border = new THREE.Line(borderGeo, borderMat);
            mapGroup.add(border);
            
            // Glow effect
            for (let i = 1; i <= 2; i++) {
                const glowMat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.35 / i
                });
                const glow = new THREE.Line(borderGeo.clone(), glowMat);
                glow.position.y = 0.12 + i * 0.01;
                glow.scale.setScalar(1 + i * 0.003);
                mapGroup.add(glow);
            }
        }
        
        function createProvinceBoundaries() {
            PROVINCES.forEach(province => {
                if (!province.bounds) return;
                
                const points = province.bounds.map(coord => {
                    const pos = latLonToXZ(coord[0], coord[1]);
                    return new THREE.Vector3(pos.x, 0.13, pos.z);
                });
                points.push(points[0].clone());
                
                // Dashed line for internal boundaries
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineDashedMaterial({
                    color: 0x8b4513,
                    dashSize: 0.05,
                    gapSize: 0.03,
                    opacity: 0.5,
                    transparent: true
                });
                
                const line = new THREE.Line(geo, mat);
                line.computeLineDistances();
                line.userData.provinceId = province.id;
                mapGroup.add(line);
                
                // Province center marker
                const pos = latLonToXZ(province.lat, province.lon);
                let y = 0.15;
                if (province.elevation === 'high') y = 0.25;
                else if (province.elevation === 'medium') y = 0.20;
                
                let color, size;
                switch (province.type) {
                    case 'capital': color = 0xffd54f; size = 0.08; break;
                    case 'major': color = 0x64b5f6; size = 0.06; break;
                    default: color = 0x7cb342; size = 0.04;
                }
                
                const markerGeo = new THREE.SphereGeometry(size, 16, 16);
                const markerMat = new THREE.MeshBasicMaterial({ color: color });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                marker.position.set(pos.x, y, pos.z);
                marker.userData.province = province;
                marker.name = 'marker';
                mapGroup.add(marker);
                
                provinceMeshes[province.id] = {
                    marker: marker,
                    boundary: line
                };
                
                // Glow ring
                const ringGeo = new THREE.RingGeometry(size * 1.2, size * 1.8, 24);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.set(pos.x, y - size + 0.01, pos.z);
                ring.rotation.x = -Math.PI / 2;
                ring.name = 'ring';
                ring.userData.provinceId = province.id;
                mapGroup.add(ring);
            });
        }
        
        function createIslands() {
            ISLANDS.forEach(island => {
                const pos = latLonToXZ(island.lat, island.lon);
                
                // Island shape
                const shape = new THREE.Shape();
                const points = 8;
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const r = island.size * (0.8 + Math.random() * 0.4);
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) shape.moveTo(x, y);
                    else shape.lineTo(x, y);
                }
                
                const geo = new THREE.ExtrudeGeometry(shape, {
                    depth: 0.03,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.005,
                    bevelSegments: 1
                });
                geo.rotateX(-Math.PI / 2);
                
                const mat = new THREE.MeshPhongMaterial({
                    color: 0x4a8c52,
                    flatShading: true
                });
                
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(pos.x, 0.01, pos.z);
                mapGroup.add(mesh);
            });
        }
        
        function createArchipelagos() {
            ARCHIPELAGOS.forEach(arch => {
                const pos = latLonToXZ(arch.lat, arch.lon);
                
                // Island cluster
                for (let i = 0; i < 8; i++) {
                    const ox = (Math.random() - 0.5) * 0.5;
                    const oz = (Math.random() - 0.5) * 0.5;
                    const size = 0.02 + Math.random() * 0.03;
                    
                    const dotGeo = new THREE.SphereGeometry(size, 8, 8);
                    const dotMat = new THREE.MeshBasicMaterial({ color: 0x5a9c5a });
                    const dot = new THREE.Mesh(dotGeo, dotMat);
                    dot.position.set(pos.x + ox, 0.02, pos.z + oz);
                    mapGroup.add(dot);
                }
                
                // Flag pole
                const poleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.3, 8);
                const poleMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.set(pos.x, 0.15, pos.z);
                mapGroup.add(pole);
                
                // Flag
                const flagGeo = new THREE.PlaneGeometry(0.15, 0.1);
                const flagMat = new THREE.MeshBasicMaterial({ color: 0xda251d, side: THREE.DoubleSide });
                const flag = new THREE.Mesh(flagGeo, flagMat);
                flag.position.set(pos.x + 0.08, 0.26, pos.z);
                flag.name = 'flag';
                mapGroup.add(flag);
                
                // Sovereignty circle
                const circleGeo = new THREE.RingGeometry(0.35, 0.38, 32);
                const circleMat = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const circle = new THREE.Mesh(circleGeo, circleMat);
                circle.position.set(pos.x, 0.01, pos.z);
                circle.rotation.x = -Math.PI / 2;
                circle.name = 'sovereignty';
                mapGroup.add(circle);
            });
        }
        
        function createProvinceList() {
            const container = document.getElementById('province-list');
            
            const regions = {
                'Th·ªß ƒë√¥ & TP TW': PROVINCES.filter(p => p.type === 'capital' || p.type === 'major'),
                'Mi·ªÅn B·∫Øc': PROVINCES.filter(p => p.region === 'B·∫Øc' && p.type === 'province'),
                'Mi·ªÅn Trung': PROVINCES.filter(p => p.region === 'Trung' && p.type === 'province'),
                'Mi·ªÅn Nam': PROVINCES.filter(p => p.region === 'Nam' && p.type === 'province')
            };
            
            Object.entries(regions).forEach(([name, provinces]) => {
                const title = document.createElement('div');
                title.className = 'region-title';
                title.textContent = `${name} (${provinces.length})`;
                container.appendChild(title);
                
                provinces.forEach(p => {
                    const item = document.createElement('div');
                    item.className = 'province-item';
                    if (p.type === 'capital') item.classList.add('capital');
                    if (p.type === 'major') item.classList.add('major');
                    item.innerHTML = `<div class="province-dot"></div>${p.name}`;
                    item.dataset.id = p.id;
                    item.dataset.name = p.name.toLowerCase();
                    item.onclick = () => selectProvince(p);
                    container.appendChild(item);
                });
            });
            
            document.getElementById('search').addEventListener('input', e => {
                const q = e.target.value.toLowerCase();
                document.querySelectorAll('.province-item').forEach(item => {
                    item.style.display = item.dataset.name.includes(q) ? 'flex' : 'none';
                });
            });
            
            document.getElementById('close-detail').onclick = () => {
                document.getElementById('detail').classList.remove('active');
                deselectProvince();
            };
        }
        
        function selectProvince(province) {
            deselectProvince();
            
            selectedProvince = province;
            
            // Highlight in list
            document.querySelectorAll('.province-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.id === province.id);
            });
            
            // Highlight boundary
            if (provinceMeshes[province.id]) {
                const { boundary, marker } = provinceMeshes[province.id];
                boundary.material.color.set(0xffd700);
                boundary.material.opacity = 1;
                boundary.material.dashSize = 0;
                marker.scale.setScalar(1.5);
            }
            
            // Show detail
            document.getElementById('detail-name').textContent = province.name;
            
            const typeEl = document.getElementById('detail-type');
            typeEl.className = 'type';
            if (province.type === 'capital') {
                typeEl.classList.add('capital');
                typeEl.textContent = 'TH·ª¶ ƒê√î';
            } else if (province.type === 'major') {
                typeEl.classList.add('major');
                typeEl.textContent = 'TP TR·ª∞C THU·ªòC TW';
            } else {
                typeEl.classList.add('province');
                typeEl.textContent = 'T·ªàNH';
            }
            
            document.getElementById('detail-area').textContent = province.area.toLocaleString() + ' km¬≤';
            document.getElementById('detail-pop').textContent = province.pop.toFixed(2) + ' tri·ªáu';
            document.getElementById('detail-region').textContent = 'Mi·ªÅn ' + province.region;
            document.getElementById('detail-density').textContent = 
                Math.round((province.pop * 1000000) / province.area).toLocaleString() + '/km¬≤';
            
            const mergedEl = document.getElementById('detail-merged');
            if (province.merged) {
                mergedEl.style.display = 'block';
                document.getElementById('merged-text').textContent = province.merged;
            } else {
                mergedEl.style.display = 'none';
            }
            
            document.getElementById('detail-features').innerHTML = province.features.map(f =>
                `<span class="feature-tag">${f}</span>`
            ).join('');
            
            document.getElementById('detail').classList.add('active');
            
            // Move camera to province
            const pos = latLonToXZ(province.lat, province.lon);
            targetRotY = -pos.x * 0.08;
            targetRotX = 0.6 + pos.z * 0.03;
        }
        
        function deselectProvince() {
            if (selectedProvince && provinceMeshes[selectedProvince.id]) {
                const { boundary, marker } = provinceMeshes[selectedProvince.id];
                boundary.material.color.set(0x8b4513);
                boundary.material.opacity = 0.5;
                boundary.material.dashSize = 0.05;
                marker.scale.setScalar(1);
            }
            selectedProvince = null;
            document.querySelectorAll('.province-item').forEach(item => item.classList.remove('selected'));
        }
        
        function setupControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', e => {
                isDragging = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', e => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                if (isDragging) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    targetRotY += dx * 0.005;
                    targetRotX = Math.max(0.25, Math.min(1.3, targetRotX + dy * 0.005));
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);
            
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                targetZoom = Math.max(0.5, Math.min(2.5, targetZoom - e.deltaY * 0.001));
            });
            
            canvas.addEventListener('click', () => {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(
                    mapGroup.children.filter(o => o.name === 'marker')
                );
                if (intersects.length > 0 && intersects[0].object.userData.province) {
                    selectProvince(intersects[0].object.userData.province);
                }
            });
            
            // Touch
            let lastTouchDist = 0;
            canvas.addEventListener('touchstart', e => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    lastTouchDist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            });
            
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) {
                    const dx = e.touches[0].clientX - prevMouse.x;
                    const dy = e.touches[0].clientY - prevMouse.y;
                    targetRotY += dx * 0.005;
                    targetRotX = Math.max(0.25, Math.min(1.3, targetRotX + dy * 0.005));
                    prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    if (lastTouchDist > 0) {
                        targetZoom = Math.max(0.5, Math.min(2.5, targetZoom + (dist - lastTouchDist) * 0.005));
                    }
                    lastTouchDist = dist;
                }
            });
            
            canvas.addEventListener('touchend', () => { isDragging = false; lastTouchDist = 0; });
        }
        
        async function initHandTracking() {
            try {
                hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}` });
                hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5 });
                hands.onResults(onHandResults);
                
                const video = document.getElementById('webcam');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                
                handCamera = new Camera(video, {
                    onFrame: async () => { if (hands) await hands.send({ image: video }); },
                    width: 320, height: 240
                });
                await handCamera.start();
            } catch (e) {
                document.getElementById('camera-feed').style.display = 'none';
            }
        }
        
        function onHandResults(results) {
            const canvas = document.getElementById('hand-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 130;
            canvas.height = 98;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
            
            results.multiHandLandmarks.forEach(landmarks => {
                drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#fff', lineWidth: 1 });
                drawLandmarks(ctx, landmarks, { color: '#7cb342', radius: 2 });
            });
            
            const landmarks = results.multiHandLandmarks[0];
            const pinch = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
            
            if (pinch < 0.08) {
                if (lastPinchDist > 0) {
                    targetZoom = Math.max(0.5, Math.min(2.5, targetZoom + (lastPinchDist - pinch) * 3));
                }
                lastPinchDist = pinch;
            } else {
                lastPinchDist = 0;
                const palm = landmarks[0];
                const fingers = [landmarks[8].y < landmarks[6].y, landmarks[12].y < landmarks[10].y,
                                landmarks[16].y < landmarks[14].y, landmarks[20].y < landmarks[18].y].filter(Boolean).length;
                if (fingers >= 4) {
                    targetRotY += (palm.x - 0.5) * 0.025;
                    targetRotX = Math.max(0.25, Math.min(1.3, targetRotX + (palm.y - 0.5) * 0.015));
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Smooth camera
            currentRotX += (targetRotX - currentRotX) * 0.05;
            currentRotY += (targetRotY - currentRotY) * 0.05;
            currentZoom += (targetZoom - currentZoom) * 0.05;
            
            mapGroup.rotation.x = currentRotX;
            mapGroup.rotation.y = currentRotY;
            mapGroup.scale.setScalar(currentZoom);
            
            // Animate flags
            mapGroup.traverse(obj => {
                if (obj.name === 'flag') {
                    obj.rotation.y = Math.sin(time * 2.5) * 0.12;
                }
                if (obj.name === 'sovereignty') {
                    obj.material.opacity = 0.35 + Math.sin(time * 2) * 0.15;
                }
                if (obj.name === 'ring') {
                    obj.scale.setScalar(1 + Math.sin(time * 2) * 0.08);
                    obj.material.opacity = 0.25 + Math.sin(time * 2) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
